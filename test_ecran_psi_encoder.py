#!/usr/bin/env python3
"""
Test pour l'√©cran PSI avec bouton encodeur rotatif
Page d'accueil pour Alimante avec navigation par encodeur
"""

import RPi.GPIO as GPIO
import time
import sys
import signal
import threading
from datetime import datetime

class RotaryEncoder:
    """Classe pour g√©rer l'encodeur rotatif"""
    
    def __init__(self, clk_pin=17, dt_pin=27, sw_pin=22, callback=None):
        """
        Initialise l'encodeur rotatif
        
        Args:
            clk_pin (int): Pin CLK de l'encodeur
            dt_pin (int): Pin DT de l'encodeur  
            sw_pin (int): Pin SW (bouton) de l'encodeur
            callback (function): Fonction appel√©e lors des changements
        """
        self.clk_pin = clk_pin
        self.dt_pin = dt_pin
        self.sw_pin = sw_pin
        self.callback = callback
        
        # √âtats pr√©c√©dents
        self.last_clk_state = 0
        self.last_sw_state = 0
        self.last_sw_time = 0
        
        # Configuration GPIO
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.clk_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(self.dt_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(self.sw_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        
        # Interruptions
        GPIO.add_event_detect(self.clk_pin, GPIO.BOTH, callback=self._clk_callback, bouncetime=2)
        GPIO.add_event_detect(self.sw_pin, GPIO.FALLING, callback=self._sw_callback, bouncetime=200)
    
    def _clk_callback(self, channel):
        """Callback pour le changement d'√©tat du pin CLK"""
        clk_state = GPIO.input(self.clk_pin)
        dt_state = GPIO.input(self.dt_pin)
        
        if clk_state != self.last_clk_state and clk_state == 0:
            if dt_state != clk_state:
                # Rotation horaire
                if self.callback:
                    self.callback('rotate_right')
            else:
                # Rotation anti-horaire
                if self.callback:
                    self.callback('rotate_left')
        
        self.last_clk_state = clk_state
    
    def _sw_callback(self, channel):
        """Callback pour l'appui sur le bouton"""
        current_time = time.time()
        if current_time - self.last_sw_time > 0.2:  # Anti-rebond
            if self.callback:
                self.callback('button_press')
            self.last_sw_time = current_time

class PSIDisplay:
    """Classe pour g√©rer l'affichage sur l'√©cran PSI"""
    
    def __init__(self):
        """Initialise l'affichage PSI"""
        self.current_page = 0
        self.menu_items = [
            "üè† Accueil Alimante",
            "üí° Test LED Bandeaux", 
            "üìä Monitoring Syst√®me",
            "‚öôÔ∏è Configuration",
            "üîß Tests Hardware",
            "üìà Statistiques",
            "‚ÑπÔ∏è √Ä propos"
        ]
        self.current_item = 0
        
    def display_page(self):
        """Affiche la page actuelle"""
        print("\n" + "="*50)
        print(f"üñ•Ô∏è  √âCRAN PSI - ALIMANTE")
        print(f"üìÖ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        print("="*50)
        
        if self.current_page == 0:  # Page d'accueil
            self._display_home()
        elif self.current_page == 1:  # Menu principal
            self._display_menu()
        else:
            self._display_content()
    
    def _display_home(self):
        """Affiche la page d'accueil"""
        print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë           üè† ALIMANTE üè†             ‚ïë
    ‚ïë                                      ‚ïë
    ‚ïë    Syst√®me de contr√¥le intelligent   ‚ïë
    ‚ïë    pour bandeaux LED et capteurs     ‚ïë
    ‚ïë                                      ‚ïë
    ‚ïë  üîÑ Tournez l'encodeur pour naviguer ‚ïë
    ‚ïë  üîò Appuyez pour s√©lectionner        ‚ïë
    ‚ïë                                      ‚ïë
    ‚ïë  üìä Status: Syst√®me op√©rationnel     ‚ïë
    ‚ïë  üí° LED: 4 bandeaux connect√©s        ‚ïë
    ‚ïë  üîß GPIO: 24 (PWM)                   ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
    
    def _display_menu(self):
        """Affiche le menu principal"""
        print("üìã MENU PRINCIPAL:")
        print("-" * 30)
        for i, item in enumerate(self.menu_items):
            marker = "‚ñ∂" if i == self.current_item else " "
            print(f"{marker} {item}")
        print("-" * 30)
        print("üîÑ Encodeur: Navigation | üîò Bouton: S√©lection")
    
    def _display_content(self):
        """Affiche le contenu de la page s√©lectionn√©e"""
        if self.current_item == 0:  # Accueil
            self._display_home()
        elif self.current_item == 1:  # Test LED
            self._display_led_test()
        elif self.current_item == 2:  # Monitoring
            self._display_monitoring()
        elif self.current_item == 3:  # Configuration
            self._display_config()
        elif self.current_item == 4:  # Tests Hardware
            self._display_hardware_tests()
        elif self.current_item == 5:  # Statistiques
            self._display_stats()
        elif self.current_item == 6:  # √Ä propos
            self._display_about()
    
    def _display_led_test(self):
        """Affiche la page de test LED"""
        print("""
üí° TEST BANDEAUX LED
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîß Configuration:
   ‚Ä¢ GPIO: 24 (PWM)
   ‚Ä¢ Fr√©quence: 1000 Hz
   ‚Ä¢ Bandeaux: 4 x 15cm

üéõÔ∏è Contr√¥les:
   ‚Ä¢ Rotation: Ajuster intensit√© (0-100%)
   ‚Ä¢ Bouton: D√©marrer/Arr√™ter test

üìä Status: Pr√™t pour test
        """)
    
    def _display_monitoring(self):
        """Affiche la page de monitoring"""
        print("""
üìä MONITORING SYST√àME
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üñ•Ô∏è √âtat Syst√®me:
   ‚Ä¢ CPU: 45% (Normal)
   ‚Ä¢ RAM: 62% (Normal) 
   ‚Ä¢ Temp: 42¬∞C (Normal)

üí° LED Status:
   ‚Ä¢ Intensit√©: 75%
   ‚Ä¢ Mode: Manuel
   ‚Ä¢ Uptime: 2h 15min

üîß GPIO Status:
   ‚Ä¢ Pin 24: Actif (PWM)
   ‚Ä¢ Encodeur: Connect√©
   ‚Ä¢ Capteurs: OK
        """)
    
    def _display_config(self):
        """Affiche la page de configuration"""
        print("""
‚öôÔ∏è CONFIGURATION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîß Param√®tres LED:
   ‚Ä¢ GPIO Pin: 24
   ‚Ä¢ Fr√©quence PWM: 1000 Hz
   ‚Ä¢ Intensit√© max: 100%

üéõÔ∏è Param√®tres Encodeur:
   ‚Ä¢ CLK Pin: 18
   ‚Ä¢ DT Pin: 19  
   ‚Ä¢ SW Pin: 20

üì° Communication:
   ‚Ä¢ Interface: I2C
   ‚Ä¢ Baudrate: 9600
        """)
    
    def _display_hardware_tests(self):
        """Affiche la page de tests hardware"""
        print("""
üîß TESTS HARDWARE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚úÖ Tests Disponibles:
   ‚Ä¢ Test GPIO (Pins 18,19,20,24)
   ‚Ä¢ Test PWM (Fr√©quence/Intensit√©)
   ‚Ä¢ Test Encodeur (Rotation/Bouton)
   ‚Ä¢ Test LED (S√©quence compl√®te)

üîÑ Rotation: S√©lectionner test
üîò Bouton: D√©marrer test s√©lectionn√©
        """)
    
    def _display_stats(self):
        """Affiche la page de statistiques"""
        print("""
üìà STATISTIQUES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚è±Ô∏è Temps de fonctionnement:
   ‚Ä¢ Total: 15h 32min
   ‚Ä¢ Aujourd'hui: 2h 15min
   ‚Ä¢ Cette semaine: 8h 45min

üí° Utilisation LED:
   ‚Ä¢ Allumages: 127
   ‚Ä¢ Intensit√© moy: 68%
   ‚Ä¢ √âconomie: 23%

üîß Actions Encodeur:
   ‚Ä¢ Rotations: 1,247
   ‚Ä¢ Clics: 89
        """)
    
    def _display_about(self):
        """Affiche la page √† propos"""
        print("""
‚ÑπÔ∏è √Ä PROPOS - ALIMANTE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üè† Alimante v1.0
   Syst√®me de contr√¥le intelligent

üë®‚Äçüíª D√©velopp√© pour:
   ‚Ä¢ Contr√¥le bandeaux LED
   ‚Ä¢ Interface encodeur rotatif
   ‚Ä¢ Monitoring syst√®me

üîß Technologies:
   ‚Ä¢ Python 3.x
   ‚Ä¢ RPi.GPIO
   ‚Ä¢ Raspberry Pi

üìû Support: contact@alimante.fr
        """)
    
    def navigate_up(self):
        """Navigation vers le haut"""
        if self.current_page == 1:  # Dans le menu
            self.current_item = (self.current_item - 1) % len(self.menu_items)
        self.display_page()
    
    def navigate_down(self):
        """Navigation vers le bas"""
        if self.current_page == 1:  # Dans le menu
            self.current_item = (self.current_item + 1) % len(self.menu_items)
        self.display_page()
    
    def select_item(self):
        """S√©lectionne l'√©l√©ment actuel"""
        if self.current_page == 0:  # Page d'accueil -> Menu
            self.current_page = 1
        elif self.current_page == 1:  # Menu -> Contenu
            self.current_page = 2
        else:  # Retour au menu
            self.current_page = 1
        
        self.display_page()

class AlimanteSystem:
    """Syst√®me principal Alimante"""
    
    def __init__(self, clk_pin=17, dt_pin=27, sw_pin=22):
        """
        Initialise le syst√®me Alimante
        
        Args:
            clk_pin (int): Pin CLK de l'encodeur
            dt_pin (int): Pin DT de l'encodeur
            sw_pin (int): Pin SW de l'encodeur
        """
        self.clk_pin = clk_pin
        self.dt_pin = dt_pin
        self.sw_pin = sw_pin
        
        # Initialisation des composants
        self.display = PSIDisplay()
        self.encoder = RotaryEncoder(clk_pin, dt_pin, sw_pin, self._encoder_callback)
        
        # Gestionnaire de signal pour arr√™t propre
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        
        self.running = True
    
    def _encoder_callback(self, action):
        """Callback pour les actions de l'encodeur"""
        if action == 'rotate_left':
            self.display.navigate_up()
        elif action == 'rotate_right':
            self.display.navigate_down()
        elif action == 'button_press':
            self.display.select_item()
    
    def _signal_handler(self, signum, frame):
        """Gestionnaire de signal pour arr√™t propre"""
        print("\nüõë Arr√™t du syst√®me Alimante...")
        self.running = False
        self.cleanup()
        sys.exit(0)
    
    def run(self):
        """Lance le syst√®me principal"""
        print("üöÄ D√©marrage du syst√®me Alimante...")
        print("üîÑ Initialisation de l'√©cran PSI et de l'encodeur...")
        
        # Affichage initial
        self.display.display_page()
        
        print("\n‚úÖ Syst√®me op√©rationnel!")
        print("üîÑ Utilisez l'encodeur pour naviguer")
        print("üîò Appuyez sur le bouton pour s√©lectionner")
        print("‚èπÔ∏è  Ctrl+C pour quitter")
        
        # Boucle principale
        try:
            while self.running:
                time.sleep(0.1)
        except KeyboardInterrupt:
            print("\nüõë Arr√™t par l'utilisateur")
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Nettoie les ressources"""
        GPIO.cleanup()
        print("üßπ Ressources nettoy√©es")

def main():
    """Fonction principale"""
    print("=" * 60)
    print("üè† ALIMANTE - Syst√®me de contr√¥le intelligent")
    print("üñ•Ô∏è  Test √©cran PSI avec encodeur rotatif")
    print("=" * 60)
    
    # Configuration des pins (modifiez selon votre c√¢blage)
    CLK_PIN = 17  # Pin CLK de l'encodeur
    DT_PIN = 27   # Pin DT de l'encodeur
    SW_PIN = 22   # Pin SW (bouton) de l'encodeur
    
    print(f"üîå Configuration GPIO:")
    print(f"   ‚Ä¢ CLK Pin: {CLK_PIN}")
    print(f"   ‚Ä¢ DT Pin: {DT_PIN}")
    print(f"   ‚Ä¢ SW Pin: {SW_PIN}")
    print()
    
    # Cr√©ation et lancement du syst√®me
    system = AlimanteSystem(CLK_PIN, DT_PIN, SW_PIN)
    
    try:
        system.run()
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
    finally:
        print("üëã Au revoir!")

if __name__ == "__main__":
    main()
